---
title: "fec16 Exploratory Data Analysis"
author: "Richard Robbins"
date: \today
header-includes: 
    - \usepackage{float}
    - \usepackage{dcolumn}
output:
  bookdown::pdf_document2:
    toc: true
---

```{r set defaults, echo=FALSE, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
```

```{r install fec16 if necessary and load libraries, echo=FALSE, include=FALSE}
if (!require("fec16")) install.packages("fec16")
library(tidyverse)
library(fec16)
theme_set(theme_minimal())
```
# Introduction

The w203 Unit 10 homework assignment revolves around the Federal Election Commission 2016 dataset available as an R package.  As I worked through that assignment I noticed several anomalies.  In the wake of the assignment I decided to go back and take a much closer look at the data.  This document summarizes what I found.

# Setup

This review looks primarily at two of the `fec16` datasets, `campaigns` and `results_house`.  The working dataset for this exercise, `df`, is formed by an inner join of `campaigns` and `results_house`, after which candidates for whom votes were not recorded are removed.  The working dataset is limited to columns of interest.  The `candidates` dataset from the `fec2016` collection is touched upon briefly in Section 3.3.

```{r load data}
campaigns <- fec16::campaigns
candidates <- fec16::candidates
results_house <- fec16::results_house
```

```{r build working dataframe}
df <- inner_join(campaigns, results_house) %>% 
  drop_na(general_votes) %>%
  select (cand_id, cand_name, pty_cd, cand_pty_affiliation, party, 
          incumbent, ttl_disb, general_votes, general_percent, won, state, district_id)
```

# Troubling Signs

## Distribution of General Election Voting Percentages

Figure \@ref(fig:preliminary-histogram) is a histogram of the general election voting percentages for candidates receiving votes as reflected in the `results_hosue` dataset.  I was surprised to see the asymmetric mass on the left hand side of the histogram.  I thought that perhaps seeing a larger group of candidates receiving low percentages might have reflected a third or fourth candidate in a contest between two other more dominant candidates.  But I struggled to come up with a satisfactory explanation nonetheless.

```{r preliminary-histogram, fig.cap="Voting Percentages", fig.width=10, fig.height=3, echo=FALSE}
vote_plot <- df %>%
  ggplot() +
  aes (x = general_percent) +
  geom_histogram (color = "black", fill = "white", bins = 100, na.rm = TRUE) +
  scale_x_continuous(labels = scales::percent) + 
  labs (title = "2016 House of Representatives general election results", 
        subtitle = paste ("mean = ", 
                          round(mean(df$general_percent, na.rm = TRUE), 3)),
        x = "percent of vote",
        y = "candidates")

vote_plot
```

## Party Affiliation

There are three ways to identify a candidate's party affiliation from the `campaigns` and `results_house` datasets.

1. `df$party` (sourced from `results_house`), 
2. `df$cand_pty_affiliation` (sourced from `campaigns`), and 
3. `df$pty_cd` (sourced from `campaigns`).

Here are the unique values from each.

```{r party affiliation, include=TRUE}
(unique (df$party))
(unique (df$cand_pty_affiliation))
(unique (df$pty_cd))
```
If we interpret "REP" and "DEM" as indicating whether the candidate is a Republican or Democrat for the two text fields, and use $1$ for Democrat and $2$ for Republican for `pty_cd`, we obtain the following.

```{r, echo=FALSE}
`%!in%` = Negate(`%in%`)

col.rep <- c(nrow(df %>% filter(party=="REP")),
             nrow(df %>% filter(cand_pty_affiliation=="REP")),
             nrow(df %>% filter(pty_cd==2)))

col.dem <- c(nrow(df %>% filter(party=="DEM")),
             nrow(df %>% filter(cand_pty_affiliation=="DEM")),
             nrow(df %>% filter(pty_cd==1)))

col.oth <- c(nrow(df %>% filter(party %!in% c("DEM", "REP"))),
             nrow(df %>% filter(cand_pty_affiliation %!in% c("DEM", "REP"))),
             nrow(df %>% filter(pty_cd > 2)))

data.frame(Republicans = col.rep, 
           Democrats = col.dem, 
           Other = col.oth, 
           row.names = c("party", "cand_pty_affiliation", "pty_cd"))
```
Using `party` yields `r nrow(df %>% filter(party %!in% c("DEM", "REP"))) - nrow(df %>% filter(cand_pty_affiliation %!in% c("DEM", "REP")))` more "other party" candidates than the alternatives.  The `cand_pty_affiliation` and `pty_cd` fields are equivalent to each other for our purposes.  That equivalency holds throughout this exercise.

Let's see what the numbers look like if we focus only one candidates who were elected.  We use `df$won` (sourced from `results_house`) to identify winners..

```{r party affiliation of winners, echo=FALSE}

col.rep <- c(nrow(df %>% filter(won & party=="REP")),
             nrow(df %>% filter(won & cand_pty_affiliation=="REP")),
             nrow(df %>% filter(won & pty_cd==2)))

col.dem <- c(nrow(df %>% filter(won & party=="DEM")),
             nrow(df %>% filter(won & cand_pty_affiliation=="DEM")),
             nrow(df %>% filter(won & pty_cd==1)))

col.oth <- c(nrow(df %>% filter(won & party %!in% c("DEM", "REP"))),
             nrow(df %>% filter(won & cand_pty_affiliation %!in% c("DEM", "REP"))),
             nrow(df %>% filter(won & pty_cd > 2)))

data.frame(Republicans = col.rep, 
           Democrats = col.dem, 
           Other = col.oth, 
           row.names = c("party", "cand_pty_affiliation", "pty_cd"))
```
The numbers are troubling.  The dataset indicates that `r nrow(df %>% filter(won))` people were elected to the House of Representatives in the 2016 election.  However, the number of voting representatives in the House of Representatives is fixed by law at no more than 435.  Moreover, after the 2016 general election, all of the voting members of the House of Representatives were either Republicans or Democrats.

## Multiple Observations For Some Candidates

While working with the data, I found instances of candidate IDs appearing more than once in`results_house` and, to a lesser degree, a candidate names appearing more than once in the `campaign` dataset.

To explore this, I wrote a pair of functions, one to count the number of times any candidate id (`cand_id`) appears more than once in a dataset, and another to count the number of times a candidate's name (`cand_name`) appears more than once in a dataset.

```{r helper functions, echo=TRUE}

redundant.names <- function (dataset){
  if ("cand_name" %in% colnames (dataset))
    {dataset %>% group_by (cand_name) %>% count() %>% filter (n>1)}
  else {NA}
}

redundant.ids <- function (dataset){
  if ("cand_id" %in% colnames (dataset))
    {dataset %>% group_by (cand_id) %>% count() %>% filter (n>1)}
  else {NA}
}
```

The table below shows the degree to which the various datasets include more than one observation for a single candidate id or name.

```{r summarize redundancies, echo=FALSE}
  
data.frame(
    dataset = c("campaigns", "candidates", "results_house", "df"),
    "redundant.names" = c(NROW(redundant.names(campaigns)),
                    NROW(redundant.names(candidates)),
                    NA,
                    NROW(redundant.names(df))),
    "redundant.ids" = c(NROW(redundant.ids(campaigns)),
                  NROW(redundant.ids(candidates)),
                  NROW(redundant.ids(results_house)),
                  NROW(redundant.ids(df))))
```

Lets take a look at the data for a few candidates appearing more than once the working dataset.

```{r gather rows with redundant candidate ids, echo=FALSE}
head(df %>%
       filter (cand_id %in% redundant.ids(df)$cand_id) %>%
       select(cand_id, cand_name, cand_pty_affiliation, pty_cd, party, 
              ttl_disb, general_votes) %>%
       arrange (cand_id)
    , 10)
```
There is a pattern.  The rows for the candidates differ in that it appears that a candidate's total vote is splintered and allocated to several parties.  

The campaign spend field (`ttl_disb`) field is consistent for a candidate.  The campaign spend information comes from the `campaigns` dataset.  From the review above, we know that we do not see redundant entries on candidate ID in that set.  So, since we see candidates with multiple entries based on candidate ID in the `results_house` dataset, when we assemble our working dataset by performing an inner join on `campaigns` and `results_house` (which uses the only common field, the candidate ID) we end up replicating campaign spend across multiple rows in the joined dataset.  That implies that our working dataset not only has too many other party candidates, the campaign spend is inflated.

I did some research and, at least for the four candidates listed above, I confirmed that the sum of the votes reflected for each above is the total number of votes the candidate received in the election.

We also see that while each of the four candidates listed above is shown as being affiliated with one of the major parties, we see other party affiliations listed.  That observation contributes to the inflated number of other party candidates we see in the data.

# Mitigation

## The Approach

Based on what I observed and discussed in Section 3.3, in particular, it seems reasonable to group the candidates by ID, party affiliation and, to be prudent, other fields that identify them.  Then we derive the vote total for the group by taking the sum of the votes reflected in each row in the group.  Party affiliation should be taken from  `pty_cd`.

In most cases where there are no duplicate entries, this step will result in the original row for the candidate being preserved.  But for candidates with multiple entries based on the candidate ID field, this step will collapse those rows into a single row where the correct number of votes will be reflected.

The cleaned date frame can be derived from the original as follows:

```{r dedupe df, message=FALSE}
df.deduped <- df %>%
  group_by(cand_id, cand_name, cand_pty_affiliation, 
           pty_cd, ttl_disb, incumbent, won) %>%
  summarise (general_votes = sum(general_votes))
```

## Assessing Mitigation Effectiveness

Let's review what the dataset looks like after the mitigation step described above.

```{r review the results}

(NROW(df))
(NROW(df.deduped))
(redundant.ids(df.deduped))
(redundant.names(df.deduped))
```

1. The number of observations has been reduced from `r NROW(df)` to `r NROW(df.deduped)`.
2. The number of redundant candidate IDs has been reduced to 1.
3. The number of redundant candidate names has been reduced to 1.

The same candidate is reflected in the second and third items above.

The breakdown by party is as follows:
```{r party review after dedupe, echo=FALSE} 

col.rep <- c(nrow(df.deduped %>% filter(cand_pty_affiliation=="REP")),
             nrow(df.deduped %>% filter(pty_cd==2)))

col.dem <- c(nrow(df.deduped %>% filter(cand_pty_affiliation=="DEM")),
             nrow(df.deduped %>% filter(pty_cd==1)))

col.oth <- c(nrow(df.deduped %>% filter(cand_pty_affiliation %!in% c("DEM", "REP"))),
             nrow(df.deduped %>% filter(pty_cd > 2)))

data.frame(Republicans = col.rep, 
           Democrats = col.dem, 
           Other = col.oth, 
           row.names = c("cand_pty_affiliation", "pty_cd"))
```
And if we isolate on the winners:

```{r party review of winners after dedupe, echo=FALSE}
col.rep <- c(nrow(df.deduped %>% filter(won & cand_pty_affiliation=="REP")),
             nrow(df.deduped %>% filter(won & pty_cd==2)))

col.dem <- c(nrow(df.deduped %>% filter(won & cand_pty_affiliation=="DEM")),
             nrow(df.deduped %>% filter(won & pty_cd==1)))

col.oth <- c(nrow(df.deduped %>% filter(won & cand_pty_affiliation %!in% c("DEM", "REP"))),
             nrow(df.deduped %>% filter(won & pty_cd > 2)))

data.frame(Republicans = col.rep, 
           Democrats = col.dem, 
           Other = col.oth, 
           row.names = c("cand_pty_affiliation", "pty_cd"))
```  

## Examining "Other Party" Winners

The six candidates identified as winning but not affiliated with a major party are:
```{r unaffiliated winners, echo=FALSE}
df.deduped %>% filter (won & pty_cd == 3)
```
- Betty McCollum and Richard Nolan are Democrats.  The dataset is incorrect.
- Rodney David and Jason Smith are Republicans.  The dataset is incorrect.
- Jennifer Gonzalez is neither a Republican nor a Democrat.  She represents Puerto Rico as a delegate.
- Greogio Sablan is now a Republican.  In 2016 he was neither a Republican nor a Democrat.  He represents the Northern Mariana Islands as a delegate.

Because Puerto Rico and the Northern Mariana Islands are territories of the United States, and not states, their representatives in the House of Representatives are delegates with limited voting privileges.  Delegates can currently vote in committee and in certain votes on the House floor, but not if their vote would be decisive. Delegates have a marginalized role in Congress and their constituents are not represented in Congress in the same manner as most citizens.

So, while there are `r NROW(df.deduped %>% filter (won))` people identified as winners in the 2016 House of Representatives election, that include 2 delegates who are not considered voting members of the House.  Accordingly, the data is now consistent with the limit on voting members in the House (435) and every voting member has been accounted for as a Republican or Democrat.

## The Lone Duplicate Entry Remaining

That leaves one person with duplicate entries in the dataset.  That distinction goes to Peter T. King.  His record was not merged because when we formed the grouping, to be conservative, we added several indicators from the dataset to prevent merging records that warranted further examination.  In this case, the dataset for Mr. King has one row indicating he is not an incumbent who lost and another indicating he is an incumbent who won.  In fact, Mr. King was an incumbent and he won re-election in 2016 with 181,506 votes.
```{r, echo=FALSE}
df.deduped %>% filter (cand_id %in% redundant.ids(df.deduped)$cand_id)
```

## Revisiting that Histogram

Unfortunately reconstructing the histogram presented above will take more effort as all of the vote percentages for the merged duplicated rows would need to be recalculated.

# What About Homework 10?

A review of the model that I built for Unit 10 is beyond what I aim to achieve in this summary.  However, I did redo much of my work using the refined dataset that reflects the changes described here.

Had I used this dataset I would have submitted a different model.  Using the original dataset, I concluded that there was a statistically significant different between Republicans and Democrats when it came to the impact of campaign spending on votes received.  In my model the constant associated with being a Democrat was higher than that of being a Republican, however, the effectiveness of campaign spend for Republicans outpaced that of Democrats.  When I repeat my work using this data, that difference disappears.  With this data, I found no difference between Republicans and Democrats.  In both cases there was a significant difference between being affiliated with one of the major parties or not.  With the cleaner data, the total residuals dropped and adjusted R^2 went from .258 to  .426.
