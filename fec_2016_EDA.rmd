---
title: "fec16 Exploratory Data Analysis"
author: "Richard Robbins"
date: \today
header-includes: 
    - \usepackage{float}
    - \usepackage{dcolumn}
output:
  bookdown::pdf_document2:
    toc: true
---

```{r set defaults, echo=FALSE, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo=TRUE)
```

```{r install fec16 if necessary and load libraries, echo=FALSE, include=FALSE, message=FALSE}
if (!require("fec16")) install.packages("fec16")
library(tidyverse)
library(knitr)
library(patchwork)
library(fec16)
theme_set(theme_minimal())
```
# Introduction

The w203 Unit 10 homework assignment revolves around some of the Federal Election Commission 2016 datasets available in the `fec16`  R package.  As I worked through that assignment I noticed several anomalies.  In the wake of the assignment I decided to go back and take a much closer look at the data.  This document summarizes what I found.  This is a work in progress.  I have identified what I believe to be the most meaningful issues in the data.

# Setup

This review looks at two of the `fec16` datasets, `campaigns` and `results_house`.  The working datasets for this exercise, `df.reference` and `df.refined` are derived  from `campaigns` and `results_house`.  The `df.reference` dataset is formed by an inner join of `campaigns` and `results_house`, after which candidates for whom votes were not recorded are removed.  The derivation of `df.refined` is described in detail below.  The working datasets are limited to columns of interest.

```{r load data}
campaigns <- fec16::campaigns
results_house <- fec16::results_house
```

```{r build working dataframe}
df.reference <- inner_join(campaigns, results_house, by="cand_id") %>% 
  drop_na(general_votes) %>%
  select (cand_id, cand_name, pty_cd, cand_pty_affiliation, party, incumbent, 
          ttl_disb, general_votes, general_percent, won, state, district_id)
```

# Troubling Signs

## Distribution of General Election Voting Percentages

Figure \@ref(fig:preliminary-histogram) is a histogram of the general election voting percentages for candidates receiving votes as reflected in the `results_house` dataset.  I was surprised to see the asymmetric mass on the left hand side of the histogram.  I thought that perhaps seeing a larger group of candidates receiving low percentages might have reflected a third or fourth candidate in a contest between two other more dominant candidates.  But I struggled to come up with a satisfactory explanation nonetheless.

```{r preliminary-histogram, fig.cap="Voting Percentages", fig.width=10, fig.height=3, echo=FALSE}
vote_plot_1 <- df.reference %>%
  ggplot() +
  aes (x = general_percent) +
  geom_histogram (color = "black", fill = "white", bins = 100, na.rm = TRUE) +
  scale_x_continuous(labels = scales::percent) + 
  labs (title = "2016 House of Representatives general election results", 
        subtitle = paste ("mean = ", 
                          round(mean(df.reference$general_percent, na.rm = TRUE), 3)),
        x = "percent of vote",
        y = "candidates")

vote_plot_1
```

## Party Affiliation

There are three ways to identify a candidate's party affiliation from the `campaigns` and `results_house` datasets: `results_house$party`, `campaigns$cand_pty_affiliation` and `campaigns$pty_cd`.  Here are the unique values from each.

```{r party affiliation, include=TRUE}
(unique (results_house$party))
(unique (campaigns$cand_pty_affiliation))
(unique (campaigns$pty_cd))
```
Party affiliation can be mapped as follows:

$$
\text{for party or cand\_pty\_affiliation:}
\begin{cases}
\text{DEM} &\rightarrow Democrat \\
\text{REP} &\rightarrow Republican \\
else &\rightarrow Other
\end{cases}
$$
$$
\text{for pty\_cd:}
\begin{cases}
1 &\rightarrow Democrat \\
2 &\rightarrow Republican \\
3 &\rightarrow Other
\end{cases}
$$
Which yields:

```{r, echo=FALSE}
`%!in%` = Negate(`%in%`)

col.rep <- c(nrow(df.reference %>% filter(party=="REP")),
             nrow(df.reference %>% filter(cand_pty_affiliation=="REP")),
             nrow(df.reference %>% filter(pty_cd==2)))

col.dem <- c(nrow(df.reference %>% filter(party=="DEM")),
             nrow(df.reference %>% filter(cand_pty_affiliation=="DEM")),
             nrow(df.reference %>% filter(pty_cd==1)))

col.oth <- c(nrow(df.reference %>% filter(party %!in% c("DEM", "REP"))),
             nrow(df.reference %>% filter(cand_pty_affiliation %!in% c("DEM", "REP"))),
             nrow(df.reference %>% filter(pty_cd > 2)))

data.frame(Republicans = col.rep, 
           Democrats = col.dem, 
           Other = col.oth, 
           row.names = c("party", "cand_pty_affiliation", "pty_cd"))
```

Using `party` yields `r nrow(df.reference %>% filter(party %!in% c("DEM", "REP"))) - nrow(df.reference %>% filter(cand_pty_affiliation %!in% c("DEM", "REP")))` more "other party" candidates than the alternatives.  The `cand_pty_affiliation` and `pty_cd` fields, as mapped, are equivalent for our purposes.

Let's review the winners (using `results_house$won`):

```{r party affiliation of winners, echo=FALSE}

col.rep <- c(nrow(df.reference %>% filter(won & party=="REP")),
             nrow(df.reference %>% filter(won & cand_pty_affiliation=="REP")),
             nrow(df.reference %>% filter(won & pty_cd==2)))

col.dem <- c(nrow(df.reference %>% filter(won & party=="DEM")),
             nrow(df.reference %>% filter(won & cand_pty_affiliation=="DEM")),
             nrow(df.reference %>% filter(won & pty_cd==1)))

col.oth <- c(nrow(df.reference %>% filter(won & party %!in% c("DEM", "REP"))),
             nrow(df.reference %>% filter(won & cand_pty_affiliation %!in% c("DEM", "REP"))),
             nrow(df.reference %>% filter(won & pty_cd > 2)))

data.frame(Republicans = col.rep, 
           Democrats = col.dem, 
           Other = col.oth, 
           row.names = c("party", "cand_pty_affiliation", "pty_cd"))
```
The numbers are troubling.  The dataset indicates that `r nrow(df.reference %>% filter(won))` people were elected to the House of Representatives in the 2016 election.  However, the number of voting representatives in the House of Representatives is fixed by law at no more than 435.  Moreover, after the 2016 general election, all of the voting members of the House of Representatives were either Republicans or Democrats.  There are also six non-voting members: a delegate representing the District of Columbia, a resident commissioner representing Puerto Rico, as well as one delegate for each of the other four permanently inhabited U.S. territories: American Samoa, Guam, the Northern Mariana Islands and the U.S. Virgin Islands.  The were, in fact, 441 people elected to the House of Representatives in the election.

## Multiple Observations For Some Candidates

While working with the data, I found instances of candidate IDs appearing more than once in `results_house` and, to a lesser degree, candidate names appearing more than once in  `campaigns`.

To explore this, a function to count the number of times any candidate id (`cand_id`) appears more than once in a dataset.

```{r helper functions, echo=TRUE}
redundant.ids <- function (dataset){
  if ("cand_id" %in% colnames (dataset))
    {dataset %>% group_by (cand_id) %>% count() %>% filter (n>1)}
  else {NA}
}
```

The table below shows the degree to which the various datasets include more than one observation for a single candidate id.

```{r summarize redundancies, echo=FALSE}
  
data.frame(
    dataset = c("campaigns", "results_house", "df.reference"),
    "redundant.ids" = c(NROW(redundant.ids(campaigns)),
                  NROW(redundant.ids(results_house)),
                  NROW(redundant.ids(df.reference))))
```

Lets take a look at the data for a few candidates appearing more than once the working dataset.

```{r gather rows with redundant candidate ids, echo=FALSE}
head(df.reference %>%
       filter (cand_id %in% redundant.ids(df.reference)$cand_id) %>%
       select (cand_id, cand_name, pty_cd, party, 
               ttl_disb, general_votes, general_percent) %>%
       arrange (cand_id)
    , 10)
```
There is a pattern.  The rows for the candidates differ in that it appears that a candidate's total vote and percent of vote received are splintered and allocated to several parties.

The campaign spend field (`ttl_disb`) field is consistent for a candidate.  That is an artifact of how we joined `campaigns` and `results_house`.  The `campaigns` dataset is the source of the campaign spending information and that dataset does not contain redundant campaign ID observations.  When we perform the join, the spending information is replicated in each redundant observation in `results_house`.  As a result, our working dataset not only has too many other party candidates, campaign spend is inflated.

Upon review of generally available election returns, for the candidates listed above, I confirmed that the total votes and correct percent of votes for each can be determined by adding the amounts shown in their respective redundant observations.

# Mitigation

## The Approach

I have come to learn that some states allow candidates to appear on multiple party lines, and that some reports separate vote totals for each party.  Therefore, for analysis that involves candidate totals, it is necessary to aggregate across all party lines within a district.  For analysis that focuses on two-party vote totals, it is necessary to account for major party candidates who receive votes under multiple party labels.  This is a topic discussed in this [codebook](https://dataverse.harvard.edu/file.xhtml?fileId=4786923&version=10.0) maintained by the MIT Election Data Science Lab.


The refined date frame can be derived from the original as follows:

```{r dedupe df, message=FALSE}
df.refined <- df.reference %>%
  group_by(cand_id, cand_name, pty_cd, incumbent, won, ttl_disb, state) %>%
  summarise (general_votes = sum(general_votes),
             general_percent = sum(general_percent),
             .groups = "keep")
```

## Assessing Mitigation Effectiveness

Let's review what the dataset looks like after the mitigation step described above.

```{r review the results, echo=TRUE}

print(NROW(df.reference))
print(NROW(df.refined))
print(redundant.ids(df.refined))
```

1. The number of observations has been reduced from `r NROW(df.reference)` to `r NROW(df.refined)`.
2. The number of redundant candidate IDs has been reduced to 1.

The breakdown by party (using `pty_cd`) is as follows:

```{r party review after dedupe, echo=FALSE} 

col.rep <- c(nrow(df.refined %>% filter(pty_cd==2)))

col.dem <- c(nrow(df.refined %>% filter(pty_cd==1)))

col.oth <- c(nrow(df.refined %>% filter(pty_cd > 2)))

data.frame(Republicans = col.rep, 
           Democrats = col.dem, 
           Other = col.oth, 
           row.names = c("pty_cd"))
```
And if we isolate on the winners:

```{r party review of winners after dedupe, echo=FALSE}
col.rep <- c(nrow(df.refined %>% filter(won & pty_cd==2)))

col.dem <- c(nrow(df.refined %>% filter(won & pty_cd==1)))

col.oth <- c(nrow(df.refined %>% filter(won & pty_cd > 2)))

data.frame(Republicans = col.rep, 
           Democrats = col.dem, 
           Other = col.oth, 
           row.names = c("pty_cd"))
```  

## Examining "Other Party" Winners

The six candidates identified as winning but not affiliated with a major party are:
```{r unaffiliated winners, echo=FALSE}
df.refined %>% filter (won & pty_cd == 3)
```
- Betty McCollum and Richard Nolan are Democrats.  The dataset is incorrect.
- Rodney David and Jason Smith are Republicans.  The dataset is incorrect.
- Jennifer Gonzalez is neither a Republican nor a Democrat.  She represents Puerto Rico as a delegate.
- Greogio Sablan is now a Republican.  In 2016 he was neither a Republican nor a Democrat.  He represents the Northern Mariana Islands as a delegate.

So, while there are `r NROW(df.refined %>% filter (won))` people identified as winners in the 2016 House of Representatives election, that includes 2 delegates who are not considered voting members of the House.  Accordingly, every voting member has been accounted for as a Republican or Democrat.  However, the total number of candidates elected was 441 consisting of 435 members with voting privileges plus six additional non-voting members, as described above.

## The Lone Duplicate Entry Remaining

That leaves one person with duplicate entries in the dataset.  That distinction goes to Peter T. King.  His record was not merged because when we formed the grouping, to be conservative, we added several indicators from the dataset to prevent merging records that warranted further examination.  In this case, the dataset for Mr. King has one row indicating he is not an incumbent who lost and another indicating he is an incumbent who won.  In fact, Mr. King was an incumbent and he won re-election in 2016 with 181,506 votes.

```{r, echo=FALSE}
df.refined %>% filter (cand_id %in% redundant.ids(df.refined)$cand_id)
```
## Revisiting that Histogram

```{r revisited-histogram, fig.cap="Revised Voting Percentages", fig.width=10, fig.height=3, echo=FALSE}
vote_plot_2 <- df.refined %>%
  ggplot() +
  aes (x = general_percent) +
  geom_histogram (color = "black", fill = "white", bins = 100, na.rm = TRUE) +
  scale_x_continuous(labels = scales::percent) + 
  labs (title = "2016 House of Representatives general election results", 
        subtitle = paste ("mean = ", 
                          round(mean(df.refined$general_percent, na.rm = TRUE), 3)),
        x = "percent of vote",
        y = "candidates")

vote_plot_2
```

Figure \@ref(fig:revisited-histogram) reproduces the histogram from Figure \@ref(fig:preliminary-histogram) using the refined dataset.  The asymmetric mass on the left hand side of the histogram is no longer present.  The histogram appears to be much more symmetric.  

However, we now appear to have a few candidates receiving more than 100% of the vote in their races.  

# Vote Totals, Write In Votes ansd Uncontested Elections

Figure \@ref(fig:revisited-histogram) suggests we should take a closer look at the voting data contained in the `results_house` dataset.  We should not see anyone with a vote percentage that exceeds 100%.  In addition, it's reasonable to expect that in most cases, the sum of the votes received by candidates on the ballot will be less than total votes cast in order to account for write in candidates.  Finally, we should think about uncontested elecetions.  We explore each of these concepts below.

## Vote Totals

We can derive the implied total number of votes cast from the number of votes received by a candidate and the percentage of votes received by that candidate, *i.e.,* $votes\_cast\ = \frac{general\_votes}{general\_percent}$.  We would expect that number to be the same when calculated across every observation for a particular race.

First, let's see votes cast for some observations.

```{r derive votes cast, include=TRUE}
results_house %>%
  drop_na(general_votes) %>%
  mutate (votes_cast = general_votes/general_percent) %>%
  select (state, district_id, cand_id, general_votes, general_percent, votes_cast)
```
That looks good.  The rows for a stete and district pair imply a consistent number of votes cast for the candidates running in that particular contest.

Next we calculate the number of unique votes cast totals for each contest.

```{r derive unique votes cast per contest, include=TRUE}
results_house %>%
  drop_na(general_votes) %>%
  mutate (votes_cast = general_votes/general_percent) %>%
  group_by(state, district_id) %>%
  summarise(unique_votes_cast = length(unique(votes_cast)), .groups = "keep")
```
That sample shows a consistent number for the contests shown.  Let's look for exceptions.

```{r look for suspicious contests, include=TRUE}
results_house %>%
  drop_na(general_votes) %>%
  mutate (votes_cast = general_votes/general_percent) %>%
  group_by(state, district_id) %>%
  summarise(unique_votes_cast = length(unique(votes_cast)), .groups = "keep") %>%
  filter(unique_votes_cast > 1)
```
That test shows more than a few contests where we appear to be getting inconsistent total votes cast numbers.  Perhaps this is due to rounding errors.  Let's round the votes cast number to the nearest integer.

```{r look for suspicious contests after rounding to the nearest integer, include=TRUE}
results_house %>%
  drop_na(general_votes) %>%
  mutate (votes_cast = round(general_votes/general_percent, 0)) %>%
  group_by(state, district_id) %>%
  summarise(unique_votes_cast = length(unique(votes_cast)), .groups = "keep") %>%
  filter(unique_votes_cast > 1)
```
We are down to just two suspicious contests.  Let's take a closer look.

```{r looking at the suspicious contests, include=TRUE}
results_house %>%
  drop_na(general_votes) %>%
  mutate (votes_cast = round(general_votes/general_percent, 0)) %>%
  group_by(state, district_id) %>%
  summarise(unique_votes_cast = length(unique(votes_cast)), 
            unique_vote_list = paste(unique(votes_cast), collapse=", "),
            .groups = "keep") %>%
  filter(unique_votes_cast > 1)
```
It seems that we were unable to calculate the total votes cast in some instances because the denominator, `general_percent` was missing.  Let's see.

```{r missing general percentages, include=TRUE}
results_house %>%
  drop_na(general_votes) %>%
  filter(is.na (general_percent)) %>%
  select (state, district_id, cand_id, general_votes, general_percent)
```
So we have two rows missing the percentage of votes received by the candidate.

## How Can A Candidate Exceed 100% Of The Vote

Now that we have gone to the trouble of confirming that the `general_votes` and `general_percent` fields yield a consistent number for total votes cast in each district, how can we explain why some candidates vote percentages as shown in Figure \@ref(fig:revisited-histogram) exceed 100%.

Here are the candidates from our deduped dataset with more than 100% of the vote.

```{r percentages too high, echo=TRUE}
df.refined %>% filter(general_percent > 1)
```
Let's go back and look at the original results data for each.

```{r percentages too high detail, echo=TRUE}
results_house %>% filter(cand_id %in% c("H2HI02110", "H6KY01110", "H6PA02171"))
```

Aha!  There's something unusual about these district identification labels.  After a little bit of additional research, I realized that in some states, when there is a vacancy created in advance of the normal expiration of a term of office, the election for the balance of the unexpired term is held separate and apart from the election for the next succeeding full term.  So, the `results_house` data is showing the "normal" full term election results with a "FULL TERM" district suffix and the unexpired term election results with the "UNEXPIRED TERM" district suffix.

We will remove results for the unexpired term elections and normalize the "FULL TERM" labels.

```{r disregard unexpired term elections and normalize district ids, echo=TRUE}

df.refined <- df.reference %>%
  filter (!grepl ("UNEXPIRED", district_id)) %>%
  mutate (district_id = str_pad(str_extract(district_id, "[:digit:]{1,2}"),
                                2, 
                                pad="0")) %>%
  group_by(cand_id, cand_name, pty_cd, incumbent, won, ttl_disb, state, district_id) %>%
  summarise (general_votes = sum(general_votes),
             general_percent = sum(general_percent),
             .groups = "keep")
```
Now let's look at the voting percentage distribution histogram,

```{r revisited-histogram-third-try, fig.cap="Revised Voting Percentages", fig.width=10, fig.height=3, echo=FALSE}
vote_plot_3 <- df.refined %>%
  ggplot() +
  aes (x = general_percent) +
  geom_histogram (color = "black", fill = "white", bins = 100, na.rm = TRUE) +
  scale_x_continuous(labels = scales::percent) + 
  labs (title = "2016 House of Representatives general election results", 
        subtitle = paste ("mean = ", 
                          round(mean(df.refined$general_percent, na.rm = TRUE), 3)),
        x = "percent of vote",
        y = "candidates")

vote_plot_3
```

The voting percentage histrogram looks much better.  The pronounced density mass on the left attributable to slivers of splintered votes has been removed and the distortions due to merging the elections for full and unexpired terms has also been removed.

## Write In Votes

Now that we have confirmed that the data for the candidates participating in a contest implies a consistent total number of votes cast in the election, let's compare the total number of votes accounted for in each contest with the number of votes cast that we have derived.  When the numbers match that means that there are no write in ballots included in the observations for that contest.  When the total votes recorded is less than the total vote cast number we expect for that election the deficit represents either missing candidates or write in ballots.  The total number of votes recorded should never exceed the votes cast number we recorded.

```{r calculate votes recorded per race, include=TRUE}
vote_reconciliation <- df.refined %>%
  mutate (implied_votes_cast = round(general_votes/general_percent, 0)) %>%
  group_by(state, district_id) %>%
  summarise(implied_votes_cast = max(implied_votes_cast, na.rm=TRUE),
            votes_recorded = sum(general_votes),
            vote_deficit = implied_votes_cast - votes_recorded,
            .groups = "keep")

summary(vote_reconciliation$vote_deficit)

sum(vote_reconciliation$vote_deficit == 0)
sum(between(vote_reconciliation$vote_deficit, 1, 1000))
sum(between(vote_reconciliation$vote_deficit, 1001, 10000))
sum(vote_reconciliation$vote_deficit > 10000)
vote_reconciliation %>% filter (vote_deficit > 10000)
```

More work to do .....

Let's repeat our vote total integrity test.

```{r look again for suspicious contests after rounding to the nearest integer, include=TRUE}
df.refined %>%
  mutate (votes_cast = round(general_votes/general_percent, 0)) %>%
  group_by(state, district_id) %>%
  summarise(unique_votes_cast = length(unique(votes_cast)), .groups = "keep") %>%
  filter(unique_votes_cast > 1)
```
No changes there.

# Using the rebuilt dataframe

```{r build final dataframe}
df.final <- results_house %>% 

  # The dataset includes full term races (the norm) and several races
  # for unexpired terms.  We eliminate the races for unexpired terms, as
  # they are special elections and separate from the full term elections.
  
  filter (!grepl ("UNEXPIRED", district_id)) %>%
  
  # Fix non-conforming district_id labels by extracting the district number
  # and preserving it as a two character string padded with leading zeros.
  # These labels reference full term races in the presence of unexpired
  # term races, which we just eliminated.
  
  mutate (district_id = str_pad(str_extract(district_id, "[:digit:]{1,2}"),
                                2, 
                                pad="0")) %>%

  # There are a few races where no votes were recorded because a candidate
  # ran unopposed, so rather than drop rows without votes recorded, we
  # keep any row for a winner including those who did not receive votes as well
  # as any row where a candidate received votes in the general election.

  filter (won | !is.na(general_votes)) %>%
  
  # There are six non-voting members: a delegate representing the 
  # District of Columbia, a resident commissioner representing Puerto Rico, 
  # as well as one delegate for each of the other four permanently inhabited 
  # U.S. territories: American Samoa, Guam, the Northern Mariana Islands and 
  # the U.S. Virgin Islands.  We create a new indicator for those races.
  
  mutate (non_voting = state %in% c("AS", "DC", "GU", "MP", "PR", "VI"),
          .after = "district_id") %>%

  # Peter King, candidate H2NY03089 was the incumbent in the 2nd district of NY.
  # He also won the general election for that seat.  A few rows in the dataset 
  # indicate that he was not the incumbet and that he lost.  We correct that.
  # The correction is needed for the next transformation to work correctly.
  
  mutate (incumbent = ifelse (cand_id == "H2NY03089", TRUE, incumbent)) %>%
  mutate (won = ifelse (cand_id == "H2NY03089", TRUE, won)) %>%
  
  # Some states allow candidates to appear on multiple party lines, separate 
  # vote totals are indicated for each party.  Therefore, for analysis that 
  # involves candidate totals, it is necessary to aggregate across all party 
  # lines within a district.  For analysis that focuses on two-party vote 
  # totals, it is necessary to account for major party candidates who receive 
  # votes under multiple party labels.
  
  group_by (state, district_id, non_voting, cand_id, incumbent, won) %>%
  summarise(general_votes=sum(general_votes), 
            general_percent=sum(general_percent),
            votes_cast=general_votes/general_percent,
            party.labels = paste(unique(party), collapse=", "),
            .groups = "keep")

# Now that the results dataset has been cleaned up, let's count the number of
# candidates.  This is useful in case we want to analyze uncontested elections.

candidate_counts <- df.final %>% 
  group_by(state, district_id) %>%
  summarise(candidate_count = length(unique(cand_id)),
            .groups = "keep")

df.final <- inner_join(df.final, candidate_counts,
                       by = c("state", "district_id"))

df.final <- inner_join(campaigns, df.final, by="cand_id") %>%
  select (state, district_id, candidate_count,non_voting, 
          cand_id, cand_name, pty_cd, incumbent, won, 
          general_votes, general_percent, votes_cast, ttl_disb)
```

## Revisiting that Histogram Again

```{r revisited-histogram-again, fig.cap="Revised Voting Percentages Again", fig.width=10, fig.height=3, echo=FALSE}
vote_plot_4 <- df.final %>% filter (candidate_count > 1) %>%
  ggplot() +
  aes (x = general_percent) +
  geom_histogram (color = "black", fill = "white", bins = 100, na.rm = TRUE) +
  scale_x_continuous(labels = scales::percent) + 
  labs (title = "2016 House of Representatives general election results", 
        subtitle = paste ("mean = ", 
                          round(mean(df.final$general_percent, na.rm = TRUE), 3)),
        x = "percent of vote",
        y = "candidates")
vote_plot_4
```

# What About Homework 10?

A review of the model that I built for Unit 10 is beyond what I aim to achieve in this summary.  However, I did redo much of my work using the refined dataset that reflects the changes described here.

Had I used this dataset I would have submitted a different model.  Using the original dataset, I concluded that there was a statistically significant different between Republicans and Democrats when it came to the impact of campaign spending on votes received.  In my model the constant associated with being a Democrat was higher than that of being a Republican, however, the effectiveness of campaign spend for Republicans outpaced that of Democrats.  When I repeat my work using this data, that difference disappears.  With this data, I found no difference between Republicans and Democrats.  In both cases there was a significant difference between being affiliated with one of the major parties or not.  With the cleaner data, the total residuals dropped and adjusted R^2 went from .258 to  .426.
