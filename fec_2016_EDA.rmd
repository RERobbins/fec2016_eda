---
title: "fec16 Exploratory Data Analysis"
author: "Richard Robbins"
date: \today
header-includes: 
    - \usepackage{float}
    - \usepackage{dcolumn}
output:
  bookdown::pdf_document2:
    toc: true
---

```{r set defaults, echo=FALSE, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo=TRUE)
```

```{r install fec16 if necessary and load libraries, echo=FALSE, include=FALSE, message=FALSE}
if (!require("fec16")) install.packages("fec16")
library(tidyverse)
library(knitr)
library(patchwork)
library(fec16)
theme_set(theme_minimal())
```
# Introduction

The w203 Unit 10 homework assignment revolves around some of the Federal Election Commission 2016 datasets available in the `fec16`  R package.  As I worked through that assignment I noticed several anomalies.  In the wake of the assignment I decided to go back and take a much closer look at the data.  This document summarizes what I found.  This is a work in progress.  I have identified what I believe to be the most meaningful issue in the data, however, as noted in Section 4.5, there are still issues to review.

# Setup

This review looks primarily at two of the `fec16` datasets, `campaigns` and `results_house`.  The working dataset for this exercise, `df`, is formed by an inner join of `campaigns` and `results_house`, after which candidates for whom votes were not recorded are removed.  The working dataset is limited to columns of interest.  The `candidates` dataset from the `fec2016` collection is also touched upon briefly in Section 3.3.

```{r load data}
campaigns <- fec16::campaigns
candidates <- fec16::candidates
results_house <- fec16::results_house
```

```{r build working dataframe}
df <- inner_join(campaigns, results_house) %>% 
  drop_na(general_votes) %>%
  select (cand_id, cand_name, pty_cd, cand_pty_affiliation, party, incumbent, 
          ttl_disb, general_votes, general_percent, won, state, district_id)
```

# Troubling Signs

## Distribution of General Election Voting Percentages

Figure \@ref(fig:preliminary-histogram) is a histogram of the general election voting percentages for candidates receiving votes as reflected in the `results_house` dataset.  I was surprised to see the asymmetric mass on the left hand side of the histogram.  I thought that perhaps seeing a larger group of candidates receiving low percentages might have reflected a third or fourth candidate in a contest between two other more dominant candidates.  But I struggled to come up with a satisfactory explanation nonetheless.

```{r preliminary-histogram, fig.cap="Voting Percentages", fig.width=10, fig.height=3, echo=FALSE}
vote_plot <- df %>%
  ggplot() +
  aes (x = general_percent) +
  geom_histogram (color = "black", fill = "white", bins = 100, na.rm = TRUE) +
  scale_x_continuous(labels = scales::percent) + 
  labs (title = "2016 House of Representatives general election results", 
        subtitle = paste ("mean = ", 
                          round(mean(df$general_percent, na.rm = TRUE), 3)),
        x = "percent of vote",
        y = "candidates")

vote_plot
```

## Party Affiliation

There are three ways to identify a candidate's party affiliation from the `campaigns` and `results_house` datasets: `results_house$party`, `campaigns$cand_pty_affiliation` and `campaigns$pty_cd`.  Here are the unique values from each.

```{r party affiliation, include=TRUE}
(unique (results_house$party))
(unique (campaigns$cand_pty_affiliation))
(unique (campaigns$pty_cd))
```
Party affiliation can be mapped as follows:

$$
\text{for party or cand\_pty\_affiliation:}
\begin{cases}
\text{DEM} &\rightarrow Democrat \\
\text{REP} &\rightarrow Republican \\
else &\rightarrow Other
\end{cases}
$$
$$
\text{for pty\_cd:}
\begin{cases}
1 &\rightarrow Democrat \\
2 &\rightarrow Republican \\
3 &\rightarrow Other
\end{cases}
$$
Which yields:

```{r, echo=FALSE}
`%!in%` = Negate(`%in%`)

col.rep <- c(nrow(df %>% filter(party=="REP")),
             nrow(df %>% filter(cand_pty_affiliation=="REP")),
             nrow(df %>% filter(pty_cd==2)))

col.dem <- c(nrow(df %>% filter(party=="DEM")),
             nrow(df %>% filter(cand_pty_affiliation=="DEM")),
             nrow(df %>% filter(pty_cd==1)))

col.oth <- c(nrow(df %>% filter(party %!in% c("DEM", "REP"))),
             nrow(df %>% filter(cand_pty_affiliation %!in% c("DEM", "REP"))),
             nrow(df %>% filter(pty_cd > 2)))

data.frame(Republicans = col.rep, 
           Democrats = col.dem, 
           Other = col.oth, 
           row.names = c("party", "cand_pty_affiliation", "pty_cd"))
```

Using `party` yields `r nrow(df %>% filter(party %!in% c("DEM", "REP"))) - nrow(df %>% filter(cand_pty_affiliation %!in% c("DEM", "REP")))` more "other party" candidates than the alternatives.  The `cand_pty_affiliation` and `pty_cd` fields, as mapped, are equivalent for our purposes.

Let's review the winners (using `results_house$won`):

```{r party affiliation of winners, echo=FALSE}

col.rep <- c(nrow(df %>% filter(won & party=="REP")),
             nrow(df %>% filter(won & cand_pty_affiliation=="REP")),
             nrow(df %>% filter(won & pty_cd==2)))

col.dem <- c(nrow(df %>% filter(won & party=="DEM")),
             nrow(df %>% filter(won & cand_pty_affiliation=="DEM")),
             nrow(df %>% filter(won & pty_cd==1)))

col.oth <- c(nrow(df %>% filter(won & party %!in% c("DEM", "REP"))),
             nrow(df %>% filter(won & cand_pty_affiliation %!in% c("DEM", "REP"))),
             nrow(df %>% filter(won & pty_cd > 2)))

data.frame(Republicans = col.rep, 
           Democrats = col.dem, 
           Other = col.oth, 
           row.names = c("party", "cand_pty_affiliation", "pty_cd"))
```
The numbers are troubling.  The dataset indicates that `r nrow(df %>% filter(won))` people were elected to the House of Representatives in the 2016 election.  However, the number of voting representatives in the House of Representatives is fixed by law at no more than 435.  Moreover, after the 2016 general election, all of the voting members of the House of Representatives were either Republicans or Democrats.

## Multiple Observations For Some Candidates

While working with the data, I found instances of candidate IDs appearing more than once in `results_house` and, to a lesser degree, candidate names appearing more than once in  `campaigns`.

To explore this, I wrote a pair of functions, one to count the number of times any candidate id (`cand_id`) appears more than once in a dataset, and another to count the number of times a candidate's name (`cand_name`) appears more than once in a dataset.

```{r helper functions, echo=TRUE}

redundant.names <- function (dataset){
  if ("cand_name" %in% colnames (dataset))
    {dataset %>% group_by (cand_name) %>% count() %>% filter (n>1)}
  else {NA}
}

redundant.ids <- function (dataset){
  if ("cand_id" %in% colnames (dataset))
    {dataset %>% group_by (cand_id) %>% count() %>% filter (n>1)}
  else {NA}
}
```

The table below shows the degree to which the various datasets include more than one observation for a single candidate id or name.

```{r summarize redundancies, echo=FALSE}
  
data.frame(
    dataset = c("campaigns", "candidates", "results_house", "df"),
    "redundant.names" = c(NROW(redundant.names(campaigns)),
                    NROW(redundant.names(candidates)),
                    NA,
                    NROW(redundant.names(df))),
    "redundant.ids" = c(NROW(redundant.ids(campaigns)),
                  NROW(redundant.ids(candidates)),
                  NROW(redundant.ids(results_house)),
                  NROW(redundant.ids(df))))
```

Lets take a look at the data for a few candidates appearing more than once the working dataset.

```{r gather rows with redundant candidate ids, echo=FALSE}
head(df %>%
       filter (cand_id %in% redundant.ids(df)$cand_id) %>%
       select(cand_id, cand_name, pty_cd, party, 
              ttl_disb, general_votes, general_percent) %>%
       arrange (cand_id)
    , 10)
```
There is a pattern.  The rows for the candidates differ in that it appears that a candidate's total vote and percent of vote received are splintered and allocated to several parties.

The campaign spend field (`ttl_disb`) field is consistent for a candidate.  That is an artifact of how we joined `campaigns` and `results_house`.  The `campaigns` dataset is the source of the campaign spending information and that dataset does not contain redundant campaign ID observations.  When we perform the join, the spending information is replicated in each redundant observation in `results_house`.  As a result, our working dataset not only has too many other party candidates, campaign spend is inflated.

Upon review of generally available election returns, for the candidates listed above, I confirmed that the total votes and correct percent of votes for each can be determined by adding the amounts shown in their respective redundant observations.

# Mitigation

## The Approach

Based on the foregoing, it seems reasonable to group the candidates by ID, name, party affiliation (using `pty_cd`) and, to be prudent, other indicator fields, such as campaign spend whether they were an incumbent and whether they won.  Then we can derive the vote and percentage of votes for each group by taking the sum of those field for each row in the group.

In most cases where there are no duplicate entries, this step will result in the original row for the candidate being preserved.  But for candidates with multiple entries based on the candidate ID field, this step will collapse those rows into a single row with the correct number of votes and percent of votes received.

The refined date frame can be derived from the original as follows:

```{r dedupe df, message=FALSE}
df.deduped <- df %>%
  group_by(cand_id, cand_name, pty_cd, incumbent, won, ttl_disb, state) %>%
  summarise (general_votes = sum(general_votes),
             general_percent = sum(general_percent),
             .groups = "keep")
```

## Assessing Mitigation Effectiveness

Let's review what the dataset looks like after the mitigation step described above.

```{r review the results}

(NROW(df))
(NROW(df.deduped))
(redundant.ids(df.deduped))
(redundant.names(df.deduped))
```

1. The number of observations has been reduced from `r NROW(df)` to `r NROW(df.deduped)`.
2. The number of redundant candidate IDs has been reduced to 1.
3. The number of redundant candidate names has been reduced to 1.

The same candidate is reflected in the second and third items above.

The breakdown by party is as follows:
```{r party review after dedupe, echo=FALSE} 

col.rep <- c(nrow(df.deduped %>% filter(pty_cd==2)))

col.dem <- c(nrow(df.deduped %>% filter(pty_cd==1)))

col.oth <- c(nrow(df.deduped %>% filter(pty_cd > 2)))

data.frame(Republicans = col.rep, 
           Democrats = col.dem, 
           Other = col.oth, 
           row.names = c("pty_cd"))
```
And if we isolate on the winners:

```{r party review of winners after dedupe, echo=FALSE}
col.rep <- c(nrow(df.deduped %>% filter(won & pty_cd==2)))

col.dem <- c(nrow(df.deduped %>% filter(won & pty_cd==1)))

col.oth <- c(nrow(df.deduped %>% filter(won & pty_cd > 2)))

data.frame(Republicans = col.rep, 
           Democrats = col.dem, 
           Other = col.oth, 
           row.names = c("pty_cd"))
```  

## Examining "Other Party" Winners

The six candidates identified as winning but not affiliated with a major party are:
```{r unaffiliated winners, echo=FALSE}
df.deduped %>% filter (won & pty_cd == 3)
```
- Betty McCollum and Richard Nolan are Democrats.  The dataset is incorrect.
- Rodney David and Jason Smith are Republicans.  The dataset is incorrect.
- Jennifer Gonzalez is neither a Republican nor a Democrat.  She represents Puerto Rico as a delegate.
- Greogio Sablan is now a Republican.  In 2016 he was neither a Republican nor a Democrat.  He represents the Northern Mariana Islands as a delegate.

Because Puerto Rico and the Northern Mariana Islands are territories of the United States, and not states, their representatives in the House of Representatives are delegates with limited voting privileges.  Delegates can currently vote in committee and in certain votes on the House floor, but not if their vote would be decisive. Delegates have a marginalized role in Congress and their constituents are not represented in Congress in the same manner as most citizens.

So, while there are `r NROW(df.deduped %>% filter (won))` people identified as winners in the 2016 House of Representatives election, that include 2 delegates who are not considered voting members of the House.  Accordingly, the data is now consistent with the limit on voting members in the House (435) and every voting member has been accounted for as a Republican or Democrat.

## The Lone Duplicate Entry Remaining

That leaves one person with duplicate entries in the dataset.  That distinction goes to Peter T. King.  His record was not merged because when we formed the grouping, to be conservative, we added several indicators from the dataset to prevent merging records that warranted further examination.  In this case, the dataset for Mr. King has one row indicating he is not an incumbent who lost and another indicating he is an incumbent who won.  In fact, Mr. King was an incumbent and he won re-election in 2016 with 181,506 votes.
```{r, echo=FALSE}
df.deduped %>% filter (cand_id %in% redundant.ids(df.deduped)$cand_id)
```

## Revisiting that Histogram

```{r revisited-histogram, fig.cap="Revised Voting Percentages", fig.width=10, fig.height=3, echo=FALSE}
vote_plot_2 <- df.deduped %>%
  ggplot() +
  aes (x = general_percent) +
  geom_histogram (color = "black", fill = "white", bins = 100, na.rm = TRUE) +
  scale_x_continuous(labels = scales::percent) + 
  labs (title = "2016 House of Representatives general election results", 
        subtitle = paste ("mean = ", 
                          round(mean(df.deduped$general_percent, na.rm = TRUE), 3)),
        x = "percent of vote",
        y = "candidates")

vote_plot_2
```


Figure \@ref(fig:revisited-histogram) reproduces the histogram from Figure \@ref(fig:preliminary-histogram) using the refined dataset.  The asymmetric mass on the left hand side of the histogram is no longer present.  The histogram appears to be much more symmetric.  

However, we now appear to have a few candidates receiving more than 100% of the vote in their races.  That suggests that there are cases where our mitigation approach is not warranted, *i.e.*, where the correct number of votes and percentages cannot be derived by adding the redundant observations.

# What About Homework 10?

A review of the model that I built for Unit 10 is beyond what I aim to achieve in this summary.  However, I did redo much of my work using the refined dataset that reflects the changes described here.

Had I used this dataset I would have submitted a different model.  Using the original dataset, I concluded that there was a statistically significant different between Republicans and Democrats when it came to the impact of campaign spending on votes received.  In my model the constant associated with being a Democrat was higher than that of being a Republican, however, the effectiveness of campaign spend for Republicans outpaced that of Democrats.  When I repeat my work using this data, that difference disappears.  With this data, I found no difference between Republicans and Democrats.  In both cases there was a significant difference between being affiliated with one of the major parties or not.  With the cleaner data, the total residuals dropped and adjusted R^2 went from .258 to  .426.
